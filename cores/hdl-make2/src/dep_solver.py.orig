# -*- coding: utf-8 -*-
#
# Copyright (c) 2011 Pawel Szostek (pawel.szostek@cern.ch)
#
#    This source code is free software; you can redistribute it
#    and/or modify it in source code form under the terms of the GNU
#    General Public License as published by the Free Software
#    Foundation; either version 2 of the License, or (at your option)
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
#

import msg as p
import global_mod


class IDependable:
    def __init__(self):
        self.dep_index = 0;
        self._dep_fixed = False;
        self.__dep_provides = [];
        self.__dep_requires = [];
        self.__dep_depends_on = [];
        pass

    #use proxy template here
    def get_dep_provides(self):
        if self._dep_fixed == False:
            self.__create_deps()
        self._dep_fixed = True
        return self.__dep_provides

    def set_dep_provides(self, what):
        self.__dep_provides = what
    dep_provides = property(get_dep_provides, set_dep_provides)

    def get_dep_requires(self):
        if self._dep_fixed == False:
            self.__create_deps()
        self._dep_fixed = True
        return self.__dep_requires

    def set_dep_requires(self, what):
        self.__dep_requires = what
    dep_requires = property(get_dep_requires, set_dep_requires)

    def get_dep_depends_on(self):
        return self.__dep_depends_on

    def set_dep_depends_on(self, what):
        self.__dep_depends_on = what
    dep_depends_on = property(get_dep_depends_on, set_dep_depends_on)

    def __create_deps(self):
        """Used solely for polymorphism"""

class DependencySolver:
    def __init__(self):
        self.entities = {};

    def __lookup_post_provider(self, files, start_index, file):
        requires = file.dep_requires
        while True:
            start_index = start_index + 1
            try:
                if type(files[start_index]) == type(file):
                    f = files[start_index]
                else:
                    continue
            except IndexError:
                break

            if requires:
                for req in requires:
                    if req in f.dep_provides: 
                        return start_index
        return None

    def __find_provider_vhdl_file(self, files, req):
        for f in files:
            if req in f.dep_provides:
                return f

        return None

    def __find_provider_verilog_file(self, req, v_file):
        from srcfile import SourceFileFactory
        import os
        vf_dirname = v_file.dirname
        p.vprint("vf_dirname name is: " + ''.join(vf_dirname))
        sff = SourceFileFactory()

        h_file = os.path.join(vf_dirname, req)
        p.vprint("req name is: " + ''.join(req))
        p.vprint("h_file name is: " + ''.join(h_file))
        if os.path.exists(h_file) and not os.path.isdir(h_file):
            return sff.new(h_file)

        inc_dirs = self.__parse_vlog_opt(v_file.vlog_opt)
        p.vprint("inc_dirs are: " + ''.join(inc_dirs))

        sff = SourceFileFactory()

        for dir in inc_dirs:
            dir = os.path.join(vf_dirname, dir)
            p.vprint("dir is: " + ''.join(dir))
            if not os.path.exists(dir) or not os.path.isdir(dir):
                p.warning("Include path "+dir+" doesn't exist")
                continue
            h_file = os.path.join(dir, req)
<<<<<<< HEAD
            p.vprint("NEW h_file name is: " + ''.join(h_file))
            if os.path.exists(h_file) and not os.path.isdir(h_file):
                p.vprint("h_file found: " + ''.join(h_file))
                sff_valid = sff.new(h_file)

                if sff_valid:
                    p.vprint("creating sff object")
                    return sff_valid
                else:
                    p.vprint("could not create sff object")         
=======
            p.vprint("h_file is: " + ''.join(h_file))
            if os.path.exists(h_file) and not os.path.isdir(h_file):
                p.vprint("h_file OK is: " + ''.join(h_file))
                return sff.new(h_file)
>>>>>>> Finalizing hdlmake2
        return None

    def __parse_vlog_opt(self, vlog_opt):
        import re
        ret = []
        #inc_pat = re.compile(".*?\+incdir\+([^ ]+)")
        inc_vsim_vlog = re.compile(".*?\+incdir\+([^ ]+)")
        # Either a normal (non-special) character or an escaped special character repeated >= 1 times
        #unix_path = re.compile(r"([^\0 \!\$\`\&\*\(\)\+]|\\(:? |\!|\$|\`|\&|\*|\(|\)|\+))+")
<<<<<<< HEAD
        vlog_vsim_opt = vlog_opt
=======

        #unix_path = re.compile(r"((:?(:?[^\0 \!\$\`\&\*\(\)\+])|(:?\\[ |\!|\$|\`|\&|\*|\(|\)|\+]))+)")
        #unix_path = re.compile(r"((:?[^\0 \!\$\`\&\*\(\)\+]|(:?\\ |\\!|\\$|\\`|\\&|\\*|\\(|\\)|\\+))+)")
        #unix_path = re.compile(r"([^\0\s\!\$\`\&\*\(\)\+]|\\\s)")
>>>>>>> Finalizing hdlmake2
        # -i unix_path one or more times
        inc_isim_vlog = re.compile(r"\s*\-i\s*((\w|/|\\ |\.|\.\.)+)\s*")

        # Try ModelSim include format (+incdir+<path>)
        while True:
<<<<<<< HEAD
            vsim_inc = re.match(inc_vsim_vlog, vlog_vsim_opt)
            if vsim_inc:
                ret.append(vsim_inc.group(1))
                vlog_vsim_opt = vlog_vsim_opt[vsim_inc.end():]
=======
            vsim_inc = re.match(inc_vsim_vlog, vlog_opt)
            if vsim_inc:
                ret.append(vsim_inc.group(1))
                vlog_opt = vlog_opt[vsim_inc.end():]
>>>>>>> Finalizing hdlmake2
            else:
                break

        # Try ISim include format (-i <path>)
        if not ret:
<<<<<<< HEAD
            vlog_isim_opt = vlog_opt
            while True:
                isim_inc = re.match(inc_isim_vlog, vlog_isim_opt)
                if isim_inc:
                    ret.append(isim_inc.group(1))
                    vlog_isim_opt = vlog_isim_opt[isim_inc.end():]
=======
            while True:
                isim_inc = re.match(inc_isim_vlog, vlog_opt)
                if isim_inc:
                    ret.append(isim_inc.group(1))
                    vlog_opt = vlog_opt[isim_inc.end():]
>>>>>>> Finalizing hdlmake2
                else:
                    break

        if global_mod.options.verbose == True:
            print "Include paths are: \n"
            print ret
        return ret

    def solve(self, fileset):
        n_iter = 0
        max_iter = 100
        import copy

        fset = fileset.filter(IDependable);

        f_nondep = []

        done = False
        while not done and (n_iter < max_iter):
            n_iter = n_iter+1
            done = True
            for f in fset:
                if not f._dep_fixed:
                    idx = fset.index(f)
                    k = self.__lookup_post_provider(files=fset, start_index=idx, file=f);

                    if k:
                        done = False
                        #swap
                        fset[idx], fset[k] = fset[k], fset[idx]

        if(n_iter == max_iter):
            p.error("Maximum number of iterations reached when trying to solve the dependencies."+
            "Perhaps a cyclic inter-dependency problem.");
            return None

        for f in fset:
            if f._dep_fixed:
                f_nondep.append(copy.copy(f))
                del f

        f_nondep.sort(key=lambda f: f.dep_index)

        from srcfile import VHDLFile, VerilogFile
        for f in [file for file in fset if isinstance(file, VHDLFile)]:
            p.vprint(f.path)
            if f.dep_requires:
                for req in f.dep_requires:
                    pf = self.__find_provider_vhdl_file([file for file in fset if isinstance(file, VHDLFile)], req)
                    if not pf:
                        p.error("Missing dependency in file "+str(f)+": " + req[0]+'.'+req[1])
                    else:
                        p.vprint("--> " + pf.path);
                        if pf.path != f.path:
                            f.dep_depends_on.append(pf)
            #get rid of duplicates by making a set from the list and vice versa
            f.dep_depends_on = list(set(f.dep_depends_on))

        import srcfile as sf

        for f in [file for file in fset if isinstance(file, VerilogFile)]:
            p.vprint(f.path)
            if f.dep_requires:
                for req in f.dep_requires:
                    pf = self.__find_provider_verilog_file(req, f)
                    if not pf:
                        p.warning("Cannot find include for file "+str(f)+": "+req)
                    else:
                        p.vprint("--> " + pf.path)
                        f.dep_depends_on.append(pf)
            #get rid of duplicates by making a set from the list and vice versa
            f.dep_depends_on = list(set(f.dep_depends_on))

            p.vprint("f.dep_depends_on is: ")
            for index in range(len(f.dep_depends_on)):
                p.vprint("[ " + str(index) + " ]: " + ''.join(f.dep_depends_on[index].path))          

        newobj = sf.SourceFileSet();
        newobj.add(f_nondep);
        for f in fset:
            try:
                if not f._dep_fixed:
                    newobj.add(f)
            except:
                newobj.add(f)

        for k in newobj:
            p.vprint(str(k.dep_index) + " " + k.path + str(k._dep_fixed))

        #p.vprint("newobj is: " + str(newobj))
        return newobj
